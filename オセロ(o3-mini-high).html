<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>プレミアムオセロゲーム 必殺技モード</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(135deg, #1e1e2f, #2a2a3d);
      color: #f5f5f5;
      transition: background 0.5s ease;
    }
    .game-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 1000px;
      padding: 20px;
      visibility: hidden;
    }
    @media (min-width: 900px) {
      .game-wrapper { flex-direction: row; align-items: flex-start; gap: 40px; }
    }
    .container {
      background: rgba(40, 40, 50, 0.9);
      border-radius: 20px;
      box-shadow: 0 15px 40px rgba(0,0,0,0.4);
      padding: 30px;
      backdrop-filter: blur(12px);
      max-width: 550px;
      width: 100%;
      margin-bottom: 20px;
      position: relative;
      overflow: hidden;
    }
    .container::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 4px;
      background: linear-gradient(to right, #ff6b6b, #feca57, #48dbfb, #1dd1a1);
      z-index: 1;
    }
    h1 { font-weight: 700; text-align: center; margin-bottom: 20px; font-size: 2.2rem; letter-spacing: 2px; }
    .status {
      margin: 15px 0;
      font-size: 18px;
      font-weight: 500;
      text-align: center;
      padding: 12px;
      border-radius: 50px;
      background: rgba(60,60,70,0.7);
      box-shadow: inset 0 2px 5px rgba(0,0,0,0.2);
      transition: all 0.3s ease;
    }
    .board-container { position: relative; margin: 20px auto; max-width: 500px; width: 100%; }
    .board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-gap: 3px;
      padding: 12px;
      background: rgba(20, 20, 30, 0.9);
      border-radius: 15px;
      box-shadow: 0 10px 20px rgba(0,0,0,0.5);
      margin: 0 auto;
      width: 100%;
    }
    .cell {
      position: relative;
      background: #2ecc71;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s ease;
      overflow: hidden;
    }
    .cell:after { content: ""; display: block; padding-bottom: 100%; }
    .cell:hover { background: #34e89e; transform: translateY(-3px); box-shadow: 0 5px 10px rgba(0,0,0,0.3); }
    .cell.last-move { background: #3dd47a; }
    .cell.sealed {
      background: rgba(100, 100, 100, 0.5);
      cursor: not-allowed;
      animation: sealPulse 1s infinite;
    }
    .cell.seal-target { background: rgba(100, 100, 255, 0.3); }
    .cell.reversal-target { background: rgba(255, 100, 100, 0.3); }
    @keyframes sealPulse { 0% { opacity: 0.5; } 50% { opacity: 0.8; } 100% { opacity: 0.5; } }
    .coordinates {
      position: absolute;
      top: 2px; left: 2px;
      font-size: 10px;
      color: rgba(255,255,255,0.4);
      pointer-events: none;
    }
    .disc {
      position: absolute;
      top: 10%; left: 10%;
      width: 80%; height: 80%;
      border-radius: 50%;
      transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1);
      box-shadow: 0 5px 15px rgba(0,0,0,0.4);
      z-index: 5;
    }
    .disc.black { background: radial-gradient(circle at 30% 30%, #555, #222); }
    .disc.white { background: radial-gradient(circle at 30% 30%, #fff, #ddd); }
    .disc.flip { transform: rotateY(180deg) scale(1.1); }
    .disc.new { animation: newDisc 0.5s ease; }
    @keyframes newDisc {
      0% { transform: scale(0); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    .players { display: flex; justify-content: space-between; margin: 20px 0; gap: 10px; width: 100%; }
    .player {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      border-radius: 15px;
      background: rgba(50,50,60,0.7);
      flex: 1;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    .player.active {
      background: rgba(80,80,90,0.9);
      box-shadow: 0 0 20px rgba(255,255,255,0.2);
    }
    .player.active::before {
      content: '';
      position: absolute; bottom: 0; left: 0;
      height: 4px; width: 100%;
      background: linear-gradient(to right, #ff6b6b, #feca57);
      animation: activePlayer 2s infinite;
    }
    @keyframes activePlayer { 0% { width: 0; } 50% { width: 100%; } 100% { width: 0; } }
    .player-title { font-size: 16px; margin-bottom: 10px; color: #ddd; }
    .player-avatar { width: 40px; height: 40px; border-radius: 50%; margin-bottom: 10px; background: #222; box-shadow: 0 0 10px rgba(0,0,0,0.3); }
    .player-avatar.white { background: #eee; box-shadow: 0 0 10px rgba(255,255,255,0.3); }
    .player-score { font-size: 22px; font-weight: bold; }
    .special-move-gauge-container {
      margin-top: 10px; width: 100%; height: 12px;
      background: rgba(30,30,30,0.5); border-radius: 6px;
      overflow: hidden;
    }
    .special-move-gauge {
      height: 100%; width: 0%;
      background: linear-gradient(135deg, #ff6b6b, #ff8e53);
      border-radius: 6px;
      transition: width 0.3s ease;
      box-shadow: 0 0 10px rgba(255, 107, 107, 0.6);
    }
    .special-move-gauge.ready { animation: pulseGauge 1.5s infinite; }
    @keyframes pulseGauge { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; } }
    .special-move-info { display: flex; flex-direction: column; align-items: center; margin-top: 5px; font-size: 12px; }
    .special-move-name { color: #f5f5f5; font-weight: bold; }
    .special-move-cooldown { color: #ff5e3a; display: none; }
    .special-move-button {
      margin-top: 5px; padding: 8px 16px;
      border-radius: 20px; background: linear-gradient(135deg, #ff6b6b, #ff8e53);
      border: none; color: white; font-size: 14px; font-weight: bold;
      cursor: pointer; opacity: 0.5; pointer-events: none;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
    }
    .special-move-button.ready { opacity: 1; pointer-events: auto; animation: pulsateButton 1.2s infinite; }
    .special-move-button.ready:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
    }
    @keyframes pulsateButton { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
    .modal, .special-move-modal {
      display: none;
      position: fixed; top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.7);
      z-index: 1000;
      justify-content: center;
      align-items: center;
      backdrop-filter: blur(5px);
    }
    .special-move-modal { background: rgba(0,0,0,0.8); z-index: 9999; backdrop-filter: blur(10px); }
    .special-move-modal.active { display: flex !important; }
    .modal-content, .special-move-modal-content {
      background: rgba(40,40,50,0.95);
      border-radius: 20px; padding: 35px;
      max-width: 600px; width: 90%;
      text-align: center;
      box-shadow: 0 20px 50px rgba(0,0,0,0.5);
      position: relative;
      animation: modalShow 0.3s ease;
    }
    @keyframes modalShow { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    .close-modal {
      position: absolute; top: 15px; right: 15px;
      font-size: 24px; cursor: pointer; color: #aaa;
      transition: color 0.3s;
    }
    .close-modal:hover { color: #fff; }
    .special-move-title, .result-title { font-size: 24px; margin-bottom: 20px; color: #f5f5f5; }
    .special-move-desc { font-size: 16px; margin-bottom: 30px; color: #ddd; }
    .special-move-options { display: flex; justify-content: center; flex-wrap: wrap; gap: 20px; margin-bottom: 30px; }
    .special-move-option {
      background: rgba(60,60,70,0.8);
      border-radius: 15px; padding: 25px; width: 180px;
      cursor: pointer; transition: all 0.3s ease;
      border: 2px solid transparent;
    }
    .special-move-option:hover { transform: translateY(-8px); box-shadow: 0 15px 25px rgba(0,0,0,0.4); }
    .special-move-option.selected { border-color: #ff8e53; background: rgba(90,90,100,0.8); }
    .special-move-icon { font-size: 40px; margin-bottom: 10px; }
    .special-move-option-name { font-size: 18px; font-weight: bold; margin-bottom: 10px; color: #f5f5f5; }
    .special-move-option-desc { font-size: 14px; color: #bbb; }
    .special-move-select-btn {
      background: linear-gradient(135deg, #ff6b6b, #ff8e53);
      color: white; border: none; padding: 12px 24px;
      border-radius: 30px; font-size: 18px; font-weight: bold;
      cursor: pointer; transition: all 0.3s ease;
    }
    .special-move-select-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0,0,0,0.3); }
    .animation-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; overflow: hidden; }
    .confetti {
      position: absolute; opacity: 0.7;
      animation: fall 4s ease-out;
      animation-fill-mode: forwards;
    }
    @keyframes fall { to { transform: translateY(100vh) rotate(720deg); } }
    .game-info { margin-top: 30px; max-width: 350px; width: 100%; }
    .statistics, .move-history {
      background: rgba(40,40,50,0.9);
      border-radius: 15px; padding: 20px;
      backdrop-filter: blur(10px);
    }
    .statistics h2, .move-history h2 { margin-bottom: 15px; font-size: 1.5rem; color: #f5f5f5; }
    .statistic-item { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1); }
    .statistic-item:last-child { border-bottom: none; }
    .history-item { display: flex; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1); }
    .move-number { width: 40px; font-weight: bold; color: #999; }
    .move-position { flex: 1; }
    .move-player { width: 40px; text-align: right; }
    .move-player .disc-mini {
      display: inline-block; width: 14px; height: 14px; border-radius: 50%; vertical-align: middle;
    }
    .move-player .disc-mini.black { background: #333; }
    .move-player .disc-mini.white { background: #eee; }
    .difficulty-selector { display: flex; justify-content: center; margin: 15px 0; }
    .difficulty-btn {
      background: transparent; border: 2px solid rgba(255,255,255,0.2);
      color: #ddd; padding: 8px 12px; margin: 0 5px; border-radius: 10px; cursor: pointer;
      transition: all 0.3s ease;
    }
    .difficulty-btn.active { background: linear-gradient(to right, #ff6b6b, #ff8e53); border-color: transparent; color: white; }
    .result-score { display: flex; justify-content: center; gap: 30px; margin: 30px 0; }
    .result-player { display: flex; flex-direction: column; align-items: center; }
    .result-avatar { width: 60px; height: 60px; border-radius: 50%; margin-bottom: 15px; }
    .result-avatar.black { background: #222; }
    .result-avatar.white { background: #eee; }
    .result-count { font-size: 28px; font-weight: bold; }
    .winner-banner {
      margin: 20px 0; padding: 10px; border-radius: 8px;
      font-weight: bold; font-size: 20px;
    }
    .winner-banner.black { background: rgba(0,0,0,0.2); }
    .winner-banner.white { background: rgba(255,255,255,0.2); }
    .winner-banner.draw { background: rgba(128,128,128,0.2); }
    .result-buttons { display: flex; justify-content: center; gap: 15px; margin-top: 30px; }
    .controls button {
      padding: 10px 20px; margin: 5px;
      background: linear-gradient(135deg, #ff6b6b, #ff8e53);
      border: none; border-radius: 20px; color: white;
      cursor: pointer; transition: all 0.3s ease;
    }
    .controls button:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
    .thinking { display: none; text-align: center; margin-top: 10px; color: #ddd; }
  </style>
</head>
<body>
  <!-- ゲームモード選択モーダル -->
  <div class="special-move-modal" id="game-mode-select-modal">
    <div class="special-move-modal-content">
      <h2 class="special-move-title">ゲームモード選択</h2>
      <p class="special-move-desc">対戦相手と先攻/後攻を選んでください</p>
      <div class="special-move-options">
        <div class="special-move-option" data-mode="player-vs-player">
          <div class="special-move-icon">👥</div>
          <div class="special-move-option-name">2人プレイ</div>
          <div class="special-move-option-desc">プレイヤー vs プレイヤー</div>
        </div>
        <div class="special-move-option selected" data-mode="player-vs-computer">
          <div class="special-move-icon">🤖</div>
          <div class="special-move-option-name">CPUと対戦</div>
          <div class="special-move-option-desc">プレイヤー vs コンピュータ</div>
        </div>
      </div>
      <div id="player-turn-selection" style="margin-top:20px;">
        <h3 style="margin-bottom:15px; color:#f5f5f5;">先攻/後攻の選択</h3>
        <div class="special-move-options" data-turn>
          <div class="special-move-option selected" data-turn="1">
            <div class="player-avatar black" style="margin:10px auto;"></div>
            <div class="special-move-option-name">黒（先攻）</div>
          </div>
          <div class="special-move-option" data-turn="2">
            <div class="player-avatar white" style="margin:10px auto;"></div>
            <div class="special-move-option-name">白（後攻）</div>
          </div>
        </div>
      </div>
      <button class="special-move-select-btn" id="confirm-game-mode">選択</button>
    </div>
  </div>

  <!-- プレイヤー1（黒）の必殺技選択モーダル -->
  <div class="special-move-modal" id="special-move-select-modal-p1">
    <div class="special-move-modal-content">
      <h2 class="special-move-title">必殺技を選択（黒プレイヤー）</h2>
      <p class="special-move-desc">ゲームで使用する必殺技を選んでください。ゲージが100%になったら使用できます。</p>
      <div class="special-move-options">
        <div class="special-move-option" data-move="seal">
          <div class="special-move-icon">🛡️</div>
          <div class="special-move-option-name">封印技</div>
          <div class="special-move-option-desc">3×3エリアを2ターン封印</div>
        </div>
        <div class="special-move-option" data-move="reversal">
          <div class="special-move-icon">🔄</div>
          <div class="special-move-option-name">反転技</div>
          <div class="special-move-option-desc">相手の駒1つを自分の色に変える</div>
        </div>
        <div class="special-move-option" data-move="chain">
          <div class="special-move-icon">⚡</div>
          <div class="special-move-option-name">連鎖技</div>
          <div class="special-move-option-desc">続けて2手打つことができる</div>
        </div>
      </div>
      <button class="special-move-select-btn" id="confirm-special-move-p1">選択</button>
    </div>
  </div>

  <!-- プレイヤー2（白）の必殺技選択モーダル -->
  <div class="special-move-modal" id="special-move-select-modal-p2">
    <div class="special-move-modal-content">
      <h2 class="special-move-title">必殺技を選択（白プレイヤー）</h2>
      <p class="special-move-desc">ゲームで使用する必殺技を選んでください。ゲージが100%になったら使用できます。</p>
      <div class="special-move-options">
        <div class="special-move-option" data-move="seal">
          <div class="special-move-icon">🛡️</div>
          <div class="special-move-option-name">封印技</div>
          <div class="special-move-option-desc">3×3エリアを2ターン封印</div>
        </div>
        <div class="special-move-option" data-move="reversal">
          <div class="special-move-icon">🔄</div>
          <div class="special-move-option-name">反転技</div>
          <div class="special-move-option-desc">相手の駒1つを自分の色に変える</div>
        </div>
        <div class="special-move-option" data-move="chain">
          <div class="special-move-icon">⚡</div>
          <div class="special-move-option-name">連鎖技</div>
          <div class="special-move-option-desc">続けて2手打つことができる</div>
        </div>
      </div>
      <button class="special-move-select-btn" id="confirm-special-move-p2">選択</button>
    </div>
  </div>

  <!-- ゲーム結果モーダル -->
  <div class="modal" id="result-modal">
    <div class="modal-content">
      <span class="close-modal" id="close-modal">×</span>
      <h2 class="result-title">ゲーム終了</h2>
      <div class="result-score">
        <div class="result-player">
          <div class="result-avatar black"></div>
          <div class="result-count" id="result-black">0</div>
        </div>
        <div class="result-player">
          <div class="result-avatar white"></div>
          <div class="result-count" id="result-white">0</div>
        </div>
      </div>
      <div class="winner-banner" id="winner-banner">勝者: 黒</div>
      <div class="result-buttons">
        <button id="new-game-btn">新しいゲーム</button>
        <button id="play-again-btn">もう一度</button>
      </div>
    </div>
  </div>

  <!-- アニメーションコンテナ -->
  <div class="animation-container" id="animation-container"></div>

  <!-- メインゲーム画面 -->
  <div class="game-wrapper">
    <div class="container">
      <h1>プレミアムオセロ 必殺技モード</h1>
      <div class="status" id="status">黒の番です</div>
      <div class="difficulty-selector">
        <button class="difficulty-btn" data-level="easy">初級</button>
        <button class="difficulty-btn active" data-level="medium">中級</button>
        <button class="difficulty-btn" data-level="hard">上級</button>
      </div>
      <div class="players">
        <div class="player active" id="player-black">
          <div class="player-title">黒</div>
          <div class="player-avatar black"></div>
          <div class="player-score" id="black-score">2</div>
          <div class="special-move-gauge-container">
            <div class="special-move-gauge" id="black-gauge"></div>
          </div>
          <div class="special-move-info">
            <span class="special-move-name" id="black-special-name">選択中...</span>
            <span class="special-move-cooldown" id="black-cooldown">クールダウン: 0</span>
          </div>
          <button class="special-move-button" id="black-special-btn">必殺技</button>
        </div>
        <div class="player" id="player-white">
          <div class="player-title">白</div>
          <div class="player-avatar white"></div>
          <div class="player-score" id="white-score">2</div>
          <div class="special-move-gauge-container">
            <div class="special-move-gauge" id="white-gauge"></div>
          </div>
          <div class="special-move-info">
            <span class="special-move-name" id="white-special-name">選択中...</span>
            <span class="special-move-cooldown" id="white-cooldown">クールダウン: 0</span>
          </div>
          <button class="special-move-button" id="white-special-btn">必殺技</button>
        </div>
      </div>
      <div class="board-container">
        <div class="board" id="board"></div>
        <div class="thinking" id="thinking">考え中<span class="thinking-dots"></span></div>
      </div>
      <div class="controls">
        <button id="reset-btn"><span>リセット</span></button>
        <button id="undo-btn"><span>元に戻す</span></button>
        <button id="hint-btn"><span>ヒント</span></button>
        <button id="skip-btn" style="display: none;"><span>パス</span></button>
      </div>
    </div>
    <div class="game-info">
      <div class="statistics">
        <h2>統計情報</h2>
        <div class="statistic-item">
          <div class="stat-label">残りマス</div>
          <div class="stat-value" id="remaining-cells">60</div>
        </div>
        <div class="statistic-item">
          <div class="stat-label">ターン数</div>
          <div class="stat-value" id="turn-count">1</div>
        </div>
        <div class="statistic-item">
          <div class="stat-label">黒の割合</div>
          <div class="stat-value" id="black-percentage">50%</div>
        </div>
        <div class="statistic-item">
          <div class="stat-label">白の割合</div>
          <div class="stat-value" id="white-percentage">50%</div>
        </div>
      </div>
      <div class="move-history">
        <h2>対局履歴</h2>
        <div id="history-list"></div>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // DOM要素の取得
      const board = document.getElementById('board');
      const status = document.getElementById('status');
      const blackScore = document.getElementById('black-score');
      const whiteScore = document.getElementById('white-score');
      const remainingCells = document.getElementById('remaining-cells');
      const turnCount = document.getElementById('turn-count');
      const blackPercentage = document.getElementById('black-percentage');
      const whitePercentage = document.getElementById('white-percentage');
      const resetBtn = document.getElementById('reset-btn');
      const undoBtn = document.getElementById('undo-btn');
      const hintBtn = document.getElementById('hint-btn');
      const skipBtn = document.getElementById('skip-btn');
      const historyList = document.getElementById('history-list');
      const playerBlack = document.getElementById('player-black');
      const playerWhite = document.getElementById('player-white');
      const animationContainer = document.getElementById('animation-container');
      const thinkingIndicator = document.getElementById('thinking');
      const resultModal = document.getElementById('result-modal');
      const closeModal = document.getElementById('close-modal');
      const resultBlack = document.getElementById('result-black');
      const resultWhite = document.getElementById('result-white');
      const winnerBanner = document.getElementById('winner-banner');
      const newGameBtn = document.getElementById('new-game-btn');
      const playAgainBtn = document.getElementById('play-again-btn');
      const difficultyBtns = document.querySelectorAll('.difficulty-btn');
      const blackGauge = document.getElementById('black-gauge');
      const whiteGauge = document.getElementById('white-gauge');
      const blackSpecialName = document.getElementById('black-special-name');
      const whiteSpecialName = document.getElementById('white-special-name');
      const blackCooldown = document.getElementById('black-cooldown');
      const whiteCooldown = document.getElementById('white-cooldown');
      const blackSpecialBtn = document.getElementById('black-special-btn');
      const whiteSpecialBtn = document.getElementById('white-special-btn');
      const gameModeModal = document.getElementById('game-mode-select-modal');
      const specialMoveModalP1 = document.getElementById('special-move-select-modal-p1');
      const specialMoveModalP2 = document.getElementById('special-move-select-modal-p2');

      // 必殺技名マッピング
      const specialMoveNames = { 'seal': '封印技', 'reversal': '反転技', 'chain': '連鎖技' };

      // 効果音設定
      const sounds = {
        place: new Audio('https://freesound.org/data/previews/242/242857_3509815-lq.mp3'),
        flip: new Audio('https://freesound.org/data/previews/518/518113_10316185-lq.mp3'),
        gaugeReady: new Audio('https://freesound.org/data/previews/270/270342_5123851-lq.mp3'),
        specialUse: new Audio('https://freesound.org/data/previews/174/174986_3242494-lq.mp3'),
        gameEnd: new Audio('https://freesound.org/data/previews/277/277021_5260872-lq.mp3')
      };
      Object.values(sounds).forEach(sound => sound.volume = 0.3);

      // ゲーム状態
      const gameState = {
        board: Array.from({length: 8}, () => Array(8).fill(0)),
        currentPlayer: 1,
        showHints: true,
        history: [],
        moveHistory: [],
        lastMove: null,
        computerPlayer: 2,
        gameMode: 'player-vs-computer',
        difficulty: 'medium',
        isComputerThinking: false,
        isGameOver: false,
        isProcessingMove: false,
        specialMoves: { 1: null, 2: null },
        specialGauges: { 1: 0, 2: 0 },
        specialCooldowns: { 1: 0, 2: 0 },
        isSpecialMoveActive: false,
        specialMoveType: null,
        chainMoveActive: false,
        chainMoveCount: 0, // 連鎖技の残り手数を管理
        sealedAreas: []
      };
      let validMovesCache = null;
      const difficultyLevels = {
        'easy': { early: 1, mid: 1, late: 1, specialChance: 0.3 },
        'medium': { early: 3, mid: 2, late: 2, specialChance: 0.6 },
        'hard': { early: 5, mid: 4, late: 3, specialChance: 0.9 }
      };
      const evaluationBoard = [
        [100,-10,8,6,6,8,-10,100],
        [-10,-25,-4,-4,-4,-4,-25,-10],
        [8,-4,6,4,4,6,-4,8],
        [6,-4,4,0,0,4,-4,6],
        [6,-4,4,0,0,4,-4,6],
        [8,-4,6,4,4,6,-4,8],
        [-10,-25,-4,-4,-4,-4,-25,-10],
        [100,-10,8,6,6,8,-10,100]
      ];

      // 初期化関連
      function renderBoard() {
        board.innerHTML = '';
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.row = row;
            cell.dataset.col = col;
            const coords = document.createElement('div');
            coords.className = 'coordinates';
            coords.textContent = `${String.fromCharCode(97 + col)}${row+1}`;
            cell.appendChild(coords);
            cell.addEventListener('click', () => handleCellClick(row, col));
            board.appendChild(cell);
          }
        }
      }

      function restoreBoard() {
        gameState.board = Array.from({length: 8}, () => Array(8).fill(0));
        gameState.board[3][3] = 2;
        gameState.board[3][4] = 1;
        gameState.board[4][3] = 1;
        gameState.board[4][4] = 2;
        renderBoard();
        updateBoard();
        showHints();
      }

      function showGameModeModal() {
        gameModeModal.style.display = 'flex';
        const modeOptions = gameModeModal.querySelectorAll('.special-move-option[data-mode]');
        modeOptions.forEach(option => {
          option.onclick = function() {
            modeOptions.forEach(opt => opt.classList.remove('selected'));
            this.classList.add('selected');
            document.getElementById('player-turn-selection').style.display = this.dataset.mode === 'player-vs-computer' ? 'block' : 'none';
          };
        });
        const turnOptions = gameModeModal.querySelectorAll('.special-move-option[data-turn]');
        turnOptions.forEach(option => {
          option.onclick = function() {
            turnOptions.forEach(opt => opt.classList.remove('selected'));
            this.classList.add('selected');
          };
        });
        document.getElementById('confirm-game-mode').onclick = function() {
          const selectedMode = gameModeModal.querySelector('.special-move-option[data-mode].selected');
          const selectedTurn = gameModeModal.querySelector('.special-move-option[data-turn].selected');
          gameState.gameMode = selectedMode.dataset.mode;
          if (gameState.gameMode === 'player-vs-computer' && selectedTurn) {
            gameState.playerTurn = parseInt(selectedTurn.dataset.turn);
            gameState.computerPlayer = gameState.playerTurn === 1 ? 2 : 1;
          }
          gameModeModal.style.display = 'none';
          showSpecialMoveModal(1);
        };
      }

      function showSpecialMoveModal(player) {
        const modal = player === 1 ? specialMoveModalP1 : specialMoveModalP2;
        modal.style.display = 'flex';
        const options = modal.querySelectorAll('.special-move-option');
        options.forEach(option => {
          option.onclick = function() {
            options.forEach(opt => opt.classList.remove('selected'));
            this.classList.add('selected');
          };
        });
        const confirmBtn = modal.querySelector('button');
        confirmBtn.onclick = function() {
          const selectedMove = modal.querySelector('.special-move-option.selected');
          if (!selectedMove) { alert('必殺技を選択してください'); return; }
          setPlayerSpecialMove(player, selectedMove.dataset.move);
          modal.style.display = 'none';
          if (gameState.gameMode === 'player-vs-player' && player === 1) {
            showSpecialMoveModal(2);
          } else {
            startGame();
          }
        };
      }

      function setPlayerSpecialMove(player, moveType) {
        gameState.specialMoves[player] = moveType;
        const nameElement = player === 1 ? blackSpecialName : whiteSpecialName;
        nameElement.textContent = specialMoveNames[moveType];
        if (player === 1 && gameState.gameMode === 'player-vs-computer') {
          const availableMoves = Object.keys(specialMoveNames);
          const randomMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
          gameState.specialMoves[2] = randomMove;
          whiteSpecialName.textContent = specialMoveNames[randomMove];
        }
      }

      function startGame() {
        document.querySelector('.game-wrapper').style.visibility = 'visible';
        restoreBoard();
        if (gameState.gameMode === 'player-vs-computer' && gameState.currentPlayer === gameState.computerPlayer) {
          setTimeout(makeComputerMove, 800);
        }
      }

      // 状態管理
      function saveGameState() {
        const boardCopy = gameState.board.map(row => [...row]);
        const specialGaugesCopy = { ...gameState.specialGauges };
        const specialCooldownsCopy = { ...gameState.specialCooldowns };
        const sealedAreasCopy = [...gameState.sealedAreas];
        gameState.history.push({
          board: boardCopy,
          currentPlayer: gameState.currentPlayer,
          lastMove: gameState.lastMove ? { ...gameState.lastMove } : null,
          specialGauges: specialGaugesCopy,
          specialCooldowns: specialCooldownsCopy,
          chainMoveActive: gameState.chainMoveActive,
          chainMoveCount: gameState.chainMoveCount,
          sealedAreas: sealedAreasCopy
        });
        if (gameState.history.length > 20) gameState.history.shift();
      }

      function undoMove() {
        if (!gameState.history.length || gameState.isComputerThinking || gameState.isProcessingMove || gameState.isSelectingSpecialTarget) return;
        const lastState = gameState.history.pop();
        gameState.board = lastState.board;
        gameState.currentPlayer = lastState.currentPlayer;
        gameState.lastMove = lastState.lastMove;
        gameState.specialGauges = lastState.specialGauges;
        gameState.specialCooldowns = lastState.specialCooldowns;
        gameState.chainMoveActive = lastState.chainMoveActive;
        gameState.chainMoveCount = lastState.chainMoveCount;
        gameState.sealedAreas = lastState.sealedAreas;
        if (gameState.moveHistory.length) gameState.moveHistory.pop();
        validMovesCache = getValidMoves(gameState.currentPlayer);
        updateBoard();
        updateGameStatus();
        updateHistoryDisplay();
        updateSpecialGauge(1, gameState.specialGauges[1]);
        updateSpecialGauge(2, gameState.specialGauges[2]);
        updateSpecialCooldown(1, gameState.specialCooldowns[1]);
        updateSpecialCooldown(2, gameState.specialCooldowns[2]);
        if (gameState.showHints) showHints();
        gameState.isGameOver = false;
        gameState.isSpecialMoveActive = false;
        gameState.isSelectingSpecialTarget = false;
      }

      function updateSpecialGauge(player, value) {
        gameState.specialGauges[player] = Math.min(Math.max(value, 0), 100);
        const gaugeElement = player === 1 ? blackGauge : whiteGauge;
        const buttonElement = player === 1 ? blackSpecialBtn : whiteSpecialBtn;
        gaugeElement.style.width = `${gameState.specialGauges[player]}%`;
        if (gameState.specialGauges[player] >= 100 && gameState.specialCooldowns[player] <= 0) {
          gaugeElement.classList.add('ready');
          buttonElement.classList.add('ready');
          if (gameState.specialGauges[player] === 100) sounds.gaugeReady.play();
        } else {
          gaugeElement.classList.remove('ready');
          buttonElement.classList.remove('ready');
        }
      }

      function updateSpecialCooldown(player, value) {
        gameState.specialCooldowns[player] = Math.max(value, 0);
        const cooldownElement = player === 1 ? blackCooldown : whiteCooldown;
        if (gameState.specialCooldowns[player] > 0) {
          cooldownElement.textContent = `クールダウン: ${gameState.specialCooldowns[player]}`;
          cooldownElement.style.display = 'block';
        } else {
          cooldownElement.style.display = 'none';
        }
      }

      function accumulateSpecialGauge() {
        const counts = countDiscs(gameState.board);
        const turnNumber = Math.floor(gameState.moveHistory.length / 2) + 1;
        let phaseMultiplier = turnNumber <= 10 ? 2.0 : (turnNumber <= 25 ? 1.5 : 1.0);
        const baseAccumulation = 7.0 * phaseMultiplier;
        const blackBonus = Math.max((counts.white - counts.black) * 0.8, 0);
        const whiteBonus = Math.max((counts.black - counts.white) * 0.8, 0);
        let positionBonus = 0;
        if (gameState.lastMove) {
          const { row, col } = gameState.lastMove;
          if ((row === 0 || row === 7) && (col === 0 || col === 7)) positionBonus = 10.0;
          else if (row === 0 || row === 7 || col === 0 || col === 7) positionBonus = 5.0;
        }
        const blackAccumulation = baseAccumulation + blackBonus + (gameState.currentPlayer === 2 ? positionBonus : 0);
        const whiteAccumulation = baseAccumulation + whiteBonus + (gameState.currentPlayer === 1 ? positionBonus : 0);
        updateSpecialGauge(1, gameState.specialGauges[1] + Math.min(blackAccumulation, 20));
        updateSpecialGauge(2, gameState.specialGauges[2] + Math.min(whiteAccumulation, 20));
        if (gameState.specialCooldowns[1] > 0) updateSpecialCooldown(1, gameState.specialCooldowns[1] - 1);
        if (gameState.specialCooldowns[2] > 0) updateSpecialCooldown(2, gameState.specialCooldowns[2] - 1);
      }

      function resetGame() {
        if (gameState.isComputerThinking || gameState.isProcessingMove) return;
        if (!confirm('ゲームをリセットしますか？')) return;
        const prevGameMode = gameState.gameMode;
        const prevPlayerTurn = gameState.playerTurn || 1;
        const prevComputerPlayer = gameState.computerPlayer || 2;
        const prevSpecialMoves = { ...gameState.specialMoves };
        gameState.board = Array.from({length: 8}, () => Array(8).fill(0));
        gameState.currentPlayer = 1;
        gameState.history = [];
        gameState.moveHistory = [];
        gameState.lastMove = null;
        gameState.computerPlayer = prevComputerPlayer;
        gameState.playerTurn = prevPlayerTurn;
        gameState.gameMode = prevGameMode;
        gameState.isComputerThinking = false;
        gameState.isGameOver = false;
        gameState.isProcessingMove = false;
        gameState.specialMoves = prevSpecialMoves;
        gameState.specialGauges = { 1: 0, 2: 0 };
        gameState.specialCooldowns = { 1: 0, 2: 0 };
        gameState.isSpecialMoveActive = false;
        gameState.specialMoveType = null;
        gameState.chainMoveActive = false;
        gameState.chainMoveCount = 0;
        gameState.sealedAreas = [];
        gameState.board[3][3] = 2; gameState.board[3][4] = 1; gameState.board[4][3] = 1; gameState.board[4][4] = 2;
        validMovesCache = getValidMoves(gameState.currentPlayer);
        updateBoard();
        updateGameStatus();
        updateHistoryDisplay();
        updateSpecialGauge(1, 0);
        updateSpecialGauge(2, 0);
        updateSpecialCooldown(1, 0);
        updateSpecialCooldown(2, 0);
        resultModal.style.display = 'none';
        if (gameState.showHints) showHints();
        if (gameState.gameMode === 'player-vs-computer' && gameState.currentPlayer === gameState.computerPlayer) {
          setTimeout(makeComputerMove, 800);
        }
      }

      // 盤面操作
      function updateBoard() {
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
            if (!cell) continue;
            const isSealed = gameState.sealedAreas.some(a => a.row === row && a.col === col);
            cell.classList.toggle('sealed', isSealed);
            if (gameState.lastMove && gameState.lastMove.row === row && gameState.lastMove.col === col) {
              cell.classList.add('last-move');
            } else {
              cell.classList.remove('last-move');
            }
            const value = gameState.board[row][col];
            let disc = cell.querySelector('.disc');
            if (value !== 0) {
              if (!disc) {
                disc = document.createElement('div');
                disc.className = `disc ${value === 1 ? 'black' : 'white'}`;
                cell.appendChild(disc);
              } else {
                disc.className = `disc ${value === 1 ? 'black' : 'white'}`;
              }
            } else if (disc) disc.remove();
          }
        }
        validMovesCache = getValidMoves(gameState.currentPlayer);
        if (gameState.showHints) showHints();
      }

      function updateGameStatus() {
        const counts = countDiscs(gameState.board);
        blackScore.textContent = counts.black;
        whiteScore.textContent = counts.white;
        const remaining = 64 - counts.black - counts.white;
        remainingCells.textContent = remaining;
        const turn = Math.floor(gameState.moveHistory.length / 2) + 1;
        turnCount.textContent = turn;
        const total = counts.black + counts.white;
        blackPercentage.textContent = total > 0 ? `${Math.round(counts.black / total * 100)}%` : '50%';
        whitePercentage.textContent = total > 0 ? `${Math.round(counts.white / total * 100)}%` : '50%';
        playerBlack.classList.toggle('active', gameState.currentPlayer === 1);
        playerWhite.classList.toggle('active', gameState.currentPlayer === 2);
        if (!gameState.isGameOver) {
          status.textContent = gameState.chainMoveActive 
            ? `${gameState.currentPlayer === 1 ? '黒' : '白'}の番です (連鎖技: 残り${gameState.chainMoveCount}手)`
            : `${gameState.currentPlayer === 1 ? '黒' : '白'}の番です`;
        }
      }

      function countDiscs(board) {
        let black = 0, white = 0;
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            if (board[row][col] === 1) black++;
            else if (board[row][col] === 2) white++;
          }
        }
        return { black, white };
      }

      function updateHistoryDisplay() {
        historyList.innerHTML = '';
        gameState.moveHistory.forEach((move, index) => {
          const historyItem = document.createElement('div');
          historyItem.className = 'history-item';
          const moveNumber = document.createElement('div');
          moveNumber.className = 'move-number';
          moveNumber.textContent = index + 1;
          const movePosition = document.createElement('div');
          movePosition.className = 'move-position';
          if (move.specialMove) {
            const icon = document.createElement('span');
            if (move.specialMove === 'seal') icon.textContent = '🛡️ ';
            else if (move.specialMove === 'reversal') icon.textContent = '🔄 ';
            else if (move.specialMove === 'chain') icon.textContent = '⚡ ';
            movePosition.appendChild(icon);
          }
          movePosition.appendChild(document.createTextNode(move.position));
          const movePlayer = document.createElement('div');
          movePlayer.className = 'move-player';
          const discMini = document.createElement('span');
          discMini.className = `disc-mini ${move.player === 1 ? 'black' : 'white'}`;
          movePlayer.appendChild(discMini);
          historyItem.append(moveNumber, movePosition, movePlayer);
          historyList.appendChild(historyItem);
        });
        historyList.scrollTop = historyList.scrollHeight;
      }

      function addMoveToHistory(row, col) {
        const colLabel = String.fromCharCode(97 + col);
        const rowLabel = row + 1;
        gameState.moveHistory.push({
          player: gameState.currentPlayer,
          position: `${colLabel}${rowLabel}`,
          row, col,
          specialMove: gameState.isSpecialMoveActive ? gameState.specialMoveType : null
        });
        updateHistoryDisplay();
      }

      function toggleHints() {
        gameState.showHints = !gameState.showHints;
        if (gameState.showHints) showHints();
        else {
          const hints = document.querySelectorAll('.valid-move');
          hints.forEach(hint => hint.remove());
        }
      }

      function showHints() {
        if (gameState.isSelectingSpecialTarget) return;
        const oldHints = document.querySelectorAll('.valid-move');
        oldHints.forEach(hint => hint.remove());
        const validMoves = getValidMoves(gameState.currentPlayer);
        validMovesCache = validMoves;
        for (const move of validMoves) {
          const cell = document.querySelector(`.cell[data-row="${move.row}"][data-col="${move.col}"]`);
          if (cell) {
            const hint = document.createElement('div');
            hint.className = `valid-move ${gameState.currentPlayer === 1 ? 'black-hint' : 'white-hint'}`;
            hint.style.cssText = 'position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; border-radius: 50%; background: rgba(255,255,255,0.3); transform: translate(-50%, -50%);';
            cell.appendChild(hint);
          }
        }
        skipBtn.style.display = validMoves.length === 0 ? 'flex' : 'none';
      }

      function handleSkip() {
        if (gameState.isComputerThinking || gameState.isProcessingMove || gameState.isGameOver) return;
        const validMoves = getValidMoves(gameState.currentPlayer);
        if (validMoves.length === 0) {
          const nextPlayer = gameState.currentPlayer === 1 ? 2 : 1;
          const nextValidMoves = getValidMoves(nextPlayer);
          if (nextValidMoves.length > 0) {
            finishTurn();
            gameState.currentPlayer = nextPlayer;
            validMovesCache = nextValidMoves;
            updateGameStatus();
            updateBoard();
            if (gameState.gameMode === 'player-vs-computer' && gameState.currentPlayer === gameState.computerPlayer) {
              setTimeout(makeComputerMove, 800);
            }
          } else {
            endGame();
          }
        }
      }

      // ゲームロジック
      function getValidMoves(player) {
        const validMoves = [];
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            if (gameState.board[row][col] === 0 && !gameState.sealedAreas.some(a => a.row === row && a.col === col)) {
              const flippedDiscs = getFlippedDiscs(gameState.board, row, col, player);
              if (flippedDiscs.length > 0) validMoves.push({ row, col, flips: flippedDiscs.length });
            }
          }
        }
        return validMoves;
      }

      function getFlippedDiscs(board, row, col, player) {
        if (row < 0 || row >= 8 || col < 0 || col >= 8 || board[row][col] !== 0) return [];
        const opponent = player === 1 ? 2 : 1;
        const dirs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
        const flippedDiscs = [];
        for (const [dx, dy] of dirs) {
          let x = row + dx, y = col + dy;
          const tempFlipped = [];
          while (x >= 0 && x < 8 && y >= 0 && y < 8 && board[x][y] === opponent) {
            tempFlipped.push({ row: x, col: y });
            x += dx; y += dy;
          }
          if (tempFlipped.length > 0 && x >= 0 && x < 8 && y >= 0 && y < 8 && board[x][y] === player) {
            flippedDiscs.push(...tempFlipped);
          }
        }
        return flippedDiscs;
      }

      function placeDisc(row, col) {
        const player = gameState.currentPlayer;
        const flippedDiscs = getFlippedDiscs(gameState.board, row, col, player);
        if (flippedDiscs.length > 0) {
          gameState.board[row][col] = player;
          const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
          if (cell) {
            const disc = document.createElement('div');
            disc.className = `disc ${player === 1 ? 'black' : 'white'} new`;
            cell.appendChild(disc);
            setTimeout(() => disc.classList.remove('new'), 500);
          }
          sounds.flip.play();
          setTimeout(() => {
            for (const discObj of flippedDiscs) {
              const cell = document.querySelector(`.cell[data-row="${discObj.row}"][data-col="${discObj.col}"]`);
              if (cell) {
                const discElement = cell.querySelector('.disc');
                if (discElement) {
                  discElement.classList.add('flip');
                  setTimeout(() => {
                    if (player === 1) { discElement.classList.remove('white'); discElement.classList.add('black'); }
                    else { discElement.classList.remove('black'); discElement.classList.add('white'); }
                    discElement.classList.remove('flip');
                  }, 250);
                }
              }
              gameState.board[discObj.row][discObj.col] = player;
            }
            updateGameStatus();
          }, 100);
        }
        return flippedDiscs;
      }

      function finishTurn() {
        accumulateSpecialGauge();
        updateSealedAreas();
      }

      function updateSealedAreas() {
        gameState.sealedAreas = gameState.sealedAreas.map(area => ({
          ...area,
          turnsRemaining: area.turnsRemaining - 1
        })).filter(area => area.turnsRemaining > 0);
      }

      function endGame() {
        gameState.isGameOver = true;
        sounds.gameEnd.play();
        const counts = countDiscs(gameState.board);
        let winner;
        if (counts.black > counts.white) {
          winner = 1;
          winnerBanner.textContent = '勝者: 黒';
          winnerBanner.className = 'winner-banner black';
        } else if (counts.white > counts.black) {
          winner = 2;
          winnerBanner.textContent = '勝者: 白';
          winnerBanner.className = 'winner-banner white';
        } else {
          winner = 0;
          winnerBanner.textContent = '引き分け';
          winnerBanner.className = 'winner-banner draw';
        }
        resultBlack.textContent = counts.black;
        resultWhite.textContent = counts.white;
        resultModal.style.display = 'flex';
        if (winner !== 0) createConfetti(winner === 1 ? '#333' : '#eee');
        status.textContent = 'ゲーム終了';
      }

      function createConfetti(color) {
        const colors = [color, '#ff6b6b', '#feca57', '#48dbfb', '#1dd1a1'];
        for (let i = 0; i < 100; i++) {
          const confetti = document.createElement('div');
          confetti.className = 'confetti';
          confetti.style.left = Math.random() * 100 + 'vw';
          confetti.style.top = -10 + 'px';
          confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
          confetti.style.width = Math.random() * 10 + 5 + 'px';
          confetti.style.height = Math.random() * 10 + 5 + 'px';
          confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
          confetti.style.animationDuration = Math.random() * 2 + 2 + 's';
          animationContainer.appendChild(confetti);
          setTimeout(() => confetti.remove(), 4000);
        }
      }

      // 必殺技関連
      function useSpecialMove(player) {
        if (gameState.specialGauges[player] < 100 || gameState.specialCooldowns[player] > 0 || !gameState.specialMoves[player]) return false;
        const moveType = gameState.specialMoves[player];
        gameState.isSpecialMoveActive = true;
        gameState.specialMoveType = moveType;
        sounds.specialUse.play();
        switch(moveType) {
          case 'seal':
            status.textContent = `${player === 1 ? '黒' : '白'}の封印技: 3×3エリアを選択（2ターン有効）`;
            gameState.isSelectingSpecialTarget = true;
            showSealTargets(player);
            highlightSealRange(player); // 範囲の事前表示
            break;
          case 'reversal':
            status.textContent = `${player === 1 ? '黒' : '白'}の反転技: 相手の駒を選択`;
            gameState.isSelectingSpecialTarget = true;
            showReversalTargets(player);
            highlightReversalTargets(player); // 対象の事前表示
            break;
          case 'chain':
            status.textContent = `${player === 1 ? '黒' : '白'}の連鎖技: 続けて2手打てます`;
            gameState.chainMoveActive = true;
            gameState.chainMoveCount = 2; // 2手分設定
            updateSpecialGauge(player, 0);
            updateSpecialCooldown(player, 2);
            updateGameStatus();
            showHints(); // 即座に有効手を表示
            setTimeout(() => {
              gameState.isSpecialMoveActive = false;
            }, 1500);
            break;
        }
        return true;
      }

      function highlightSealRange(player) {
        // すべてのマスに選択可能な範囲を示す（実際の適用はクリック時）
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
            if (cell) {
              cell.classList.add('seal-target');
            }
          }
        }
      }

      function showSealTargets(player) {
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
            if (cell) {
              cell.addEventListener('click', handleSealTarget);
            }
          }
        }
      }

      function handleSealTarget(event) {
        const cell = event.currentTarget;
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        applySeal(row, col, gameState.currentPlayer);
        const targetCells = document.querySelectorAll('.seal-target');
        targetCells.forEach(cell => {
          cell.classList.remove('seal-target');
          cell.removeEventListener('click', handleSealTarget);
        });
        updateSpecialGauge(gameState.currentPlayer, 0);
        updateSpecialCooldown(gameState.currentPlayer, 2);
        gameState.isSelectingSpecialTarget = false;
        gameState.isSpecialMoveActive = false;
        status.textContent = `${gameState.currentPlayer === 1 ? '黒' : '白'}の番です`;
        updateBoard();
        switchPlayer();
      }

      function applySeal(centerRow, centerCol, player) {
        for (let r = centerRow - 1; r <= centerRow + 1; r++) {
          for (let c = centerCol - 1; c <= centerCol + 1; c++) {
            if (r >= 0 && r < 8 && c >= 0 && c < 8) {
              gameState.sealedAreas.push({ row: r, col: c, player, turnsRemaining: 2 }); // 2ターン持続
            }
          }
        }
      }

      function highlightReversalTargets(player) {
        const opponent = player === 1 ? 2 : 1;
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            if (gameState.board[row][col] === opponent) {
              const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
              if (cell) {
                cell.classList.add('reversal-target');
              }
            }
          }
        }
      }

      function showReversalTargets(player) {
        const opponent = player === 1 ? 2 : 1;
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            if (gameState.board[row][col] === opponent) {
              const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
              if (cell) {
                cell.addEventListener('click', handleReversalTarget);
              }
            }
          }
        }
      }

      function handleReversalTarget(event) {
        const cell = event.currentTarget;
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        gameState.board[row][col] = gameState.currentPlayer;
        const disc = cell.querySelector('.disc');
        if (disc) {
          disc.classList.add('flip');
          setTimeout(() => { disc.className = `disc ${gameState.currentPlayer === 1 ? 'black' : 'white'}`; }, 250);
        }
        const targetCells = document.querySelectorAll('.reversal-target');
        targetCells.forEach(cell => {
          cell.classList.remove('reversal-target');
          cell.removeEventListener('click', handleReversalTarget);
        });
        updateSpecialGauge(gameState.currentPlayer, 0);
        updateSpecialCooldown(gameState.currentPlayer, 2);
        gameState.isSelectingSpecialTarget = false;
        gameState.isSpecialMoveActive = false;
        status.textContent = `${gameState.currentPlayer === 1 ? '黒' : '白'}の番です`;
        updateBoard();
        switchPlayer();
      }

      function makeComputerMove() {
        if (gameState.isGameOver || !gameState.currentPlayer) return;
        gameState.isComputerThinking = true;
        gameState.isProcessingMove = true;
        thinkingIndicator.style.display = 'block';
        setTimeout(() => {
          const validMoves = getValidMoves(gameState.currentPlayer);
          if (validMoves.length === 0) {
            handleSkip();
            gameState.isComputerThinking = false;
            gameState.isProcessingMove = false;
            thinkingIndicator.style.display = 'none';
            return;
          }
          const usedSpecialMove = computerUseSpecialMove();
          if (usedSpecialMove) {
            const moveType = gameState.specialMoves[2];
            switch(moveType) {
              case 'seal':
                setTimeout(() => {
                  computerSelectSealTarget();
                  updateBoard();
                  setTimeout(() => computerPlayNormalMove(), 1000);
                }, 1000);
                break;
              case 'reversal':
                setTimeout(() => {
                  computerSelectReversalTarget();
                  updateBoard();
                  setTimeout(() => computerPlayNormalMove(), 1000);
                }, 1000);
                break;
              case 'chain':
                computerPlayNormalMove(true);
                break;
            }
          } else {
            computerPlayNormalMove();
          }
        }, 800);
      }

      function computerUseSpecialMove() {
        if (gameState.specialGauges[2] < 100 || gameState.specialCooldowns[2] > 0 || !gameState.specialMoves[2]) return false;
        let useChance = difficultyLevels[gameState.difficulty].specialChance;
        const counts = countDiscs(gameState.board);
        if (counts.white < counts.black) useChance += 0.2;
        if (Math.random() < useChance) return useSpecialMove(2);
        return false;
      }

      function computerSelectSealTarget() {
        const validMoves = getValidMoves(1);
        if (validMoves.length > 0) {
          const target = validMoves.reduce((best, move) => 
            evaluationBoard[move.row][move.col] > evaluationBoard[best.row][best.col] ? move : best
          );
          applySeal(target.row, target.col, 2);
          updateSpecialGauge(2, 0);
          updateSpecialCooldown(2, 2);
          gameState.isSpecialMoveActive = false;
          status.textContent = `白の番です`;
        }
      }

      function computerSelectReversalTarget() {
        const targets = [];
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            if (gameState.board[row][col] === 1) targets.push({ row, col, value: evaluationBoard[row][col] });
          }
        }
        if (targets.length === 0) return null;
        targets.sort((a, b) => b.value - a.value);
        const target = targets[Math.min(Math.floor(Math.random() * 3), targets.length - 1)];
        gameState.board[target.row][target.col] = 2;
        const cell = document.querySelector(`.cell[data-row="${target.row}"][data-col="${target.col}"]`);
        if (cell) {
          const disc = cell.querySelector('.disc');
          if (disc) {
            disc.classList.add('flip');
            setTimeout(() => { disc.className = `disc white`; }, 250);
          }
        }
        updateSpecialGauge(2, 0);
        updateSpecialCooldown(2, 2);
        gameState.isSpecialMoveActive = false;
        status.textContent = `白の番です`;
        return target;
      }

      function computerPlayNormalMove(isChainMove = false) {
        const validMoves = getValidMoves(gameState.currentPlayer);
        validMovesCache = validMoves;
        if (validMoves.length > 0) {
          const bestMove = findBestMove(validMoves);
          saveGameState();
          sounds.place.play();
          placeDisc(bestMove.row, bestMove.col);
          addMoveToHistory(bestMove.row, bestMove.col);
          gameState.lastMove = { row: bestMove.row, col: bestMove.col };
          if (isChainMove && gameState.chainMoveCount > 0) {
            gameState.chainMoveCount--;
            if (gameState.chainMoveCount > 0) {
              updateGameStatus();
              updateBoard();
              setTimeout(() => computerPlayNormalMove(true), 1000);
            } else {
              gameState.chainMoveActive = false;
              gameState.chainMoveCount = 0;
              finishTurn();
              switchPlayer();
              updateBoard();
              gameState.isComputerThinking = false;
              gameState.isProcessingMove = false;
              thinkingIndicator.style.display = 'none';
            }
          } else {
            finishTurn();
            switchPlayer();
            updateBoard();
            gameState.isComputerThinking = false;
            gameState.isProcessingMove = false;
            thinkingIndicator.style.display = 'none';
          }
        } else {
          gameState.chainMoveActive = false;
          gameState.chainMoveCount = 0;
          finishTurn();
          switchPlayer();
          gameState.isComputerThinking = false;
          gameState.isProcessingMove = false;
          thinkingIndicator.style.display = 'none';
        }
      }

      function switchPlayer() {
        const nextPlayer = gameState.currentPlayer === 1 ? 2 : 1;
        const nextValidMoves = getValidMoves(nextPlayer);
        if (nextValidMoves.length > 0) {
          gameState.currentPlayer = nextPlayer;
          validMovesCache = nextValidMoves;
          updateGameStatus();
          updateBoard();
          if (gameState.gameMode === 'player-vs-computer' && gameState.currentPlayer === gameState.computerPlayer) {
            setTimeout(makeComputerMove, 800);
          }
        } else {
          const currentValid = getValidMoves(gameState.currentPlayer);
          if (currentValid.length === 0) endGame();
          else {
            status.textContent = `${nextPlayer === 1 ? '黒' : '白'}は打つ場所がありません。${gameState.currentPlayer === 1 ? '黒' : '白'}の番が続きます。`;
            validMovesCache = currentValid;
          }
        }
      }

      function findBestMove(validMoves) {
        let bestScore = -Infinity, bestMove = validMoves[0];
        const counts = countDiscs(gameState.board);
        const totalDiscs = counts.black + counts.white;
        let gameStage = totalDiscs <= 20 ? 'early' : (totalDiscs <= 40 ? 'mid' : 'late');
        const depth = difficultyLevels[gameState.difficulty][gameStage];
        for (const move of validMoves) {
          const boardCopy = gameState.board.map(row => [...row]);
          placeDiscOnBoard(boardCopy, move.row, move.col, gameState.currentPlayer);
          const score = minimax(boardCopy, depth - 1, -Infinity, Infinity, false, gameState.currentPlayer === 1 ? 2 : 1);
          if (score > bestScore) { bestScore = score; bestMove = move; }
        }
        return bestMove;
      }

            function minimax(board, depth, alpha, beta, isMaximizing, player) {
        if (depth === 0) return evaluateBoard(board, gameState.computerPlayer);
        const opponent = player === 1 ? 2 : 1;
        const validMoves = getValidMovesForBoard(board, player);
        if (validMoves.length === 0) {
          const opponentMoves = getValidMovesForBoard(board, opponent);
          if (opponentMoves.length === 0) return finalEvaluation(board, gameState.computerPlayer);
          return minimax(board, depth - 1, alpha, beta, !isMaximizing, opponent);
        }
        if (isMaximizing) {
          let maxScore = -Infinity;
          for (const move of validMoves) {
            const boardCopy = board.map(row => [...row]);
            placeDiscOnBoard(boardCopy, move.row, move.col, player);
            const score = minimax(boardCopy, depth - 1, alpha, beta, false, opponent);
            maxScore = Math.max(maxScore, score);
            alpha = Math.max(alpha, score);
            if (beta <= alpha) break;
          }
          return maxScore;
        } else {
          let minScore = Infinity;
          for (const move of validMoves) {
            const boardCopy = board.map(row => [...row]);
            placeDiscOnBoard(boardCopy, move.row, move.col, player);
            const score = minimax(boardCopy, depth - 1, alpha, beta, true, opponent);
            minScore = Math.min(minScore, score);
            beta = Math.min(beta, score);
            if (beta <= alpha) break;
          }
          return minScore;
        }
      }

      function getValidMovesForBoard(board, player) {
        const validMoves = [];
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            if (board[row][col] === 0) {
              const flippedDiscs = getFlippedDiscs(board, row, col, player);
              if (flippedDiscs.length > 0) validMoves.push({ row, col, flips: flippedDiscs.length });
            }
          }
        }
        return validMoves;
      }

      function placeDiscOnBoard(board, row, col, player) {
        const flippedDiscs = getFlippedDiscs(board, row, col, player);
        if (flippedDiscs.length > 0) {
          board[row][col] = player;
          for (const disc of flippedDiscs) board[disc.row][disc.col] = player;
        }
        return flippedDiscs;
      }

      function evaluateBoard(board, player) {
        let score = 0;
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            if (board[row][col] === player) score += evaluationBoard[row][col];
            else if (board[row][col] === (player === 1 ? 2 : 1)) score -= evaluationBoard[row][col];
          }
        }
        return score;
      }

      function finalEvaluation(board, player) {
        const counts = countDiscs(board);
        return player === 1 ? counts.black - counts.white : counts.white - counts.black;
      }

      // セルクリック処理
      function handleCellClick(row, col) {
        if (gameState.isComputerThinking || gameState.isGameOver || gameState.isProcessingMove || gameState.isSelectingSpecialTarget) return;
        if (gameState.gameMode === 'player-vs-computer' && gameState.currentPlayer === gameState.computerPlayer) return;
        const validMoves = getValidMoves(gameState.currentPlayer);
        validMovesCache = validMoves;
        const selectedMove = validMoves.find(move => move.row === row && move.col === col);
        if (!selectedMove) return;
        gameState.isProcessingMove = true;
        sounds.place.play();
        saveGameState();
        placeDisc(row, col);
        addMoveToHistory(row, col);
        gameState.lastMove = { row, col };
        
        if (gameState.chainMoveActive) {
          gameState.chainMoveCount--;
          if (gameState.chainMoveCount <= 0) {
            gameState.chainMoveActive = false;
            gameState.chainMoveCount = 0;
            finishTurn();
            switchPlayer();
          } else {
            updateGameStatus();
            updateBoard();
          }
        } else {
          finishTurn();
          switchPlayer();
        }
        updateBoard();
        setTimeout(() => { gameState.isProcessingMove = false; }, 600);
      }

      // 難易度変更
      function changeDifficulty(level) {
        gameState.difficulty = level;
        difficultyBtns.forEach(btn => btn.classList.toggle('active', btn.dataset.level === level));
      }

      // イベントリスナー設定
      blackSpecialBtn.addEventListener('click', function() {
        if (gameState.currentPlayer !== 1 || gameState.specialGauges[1] < 100 || gameState.specialCooldowns[1] > 0 || gameState.isProcessingMove || gameState.isComputerThinking) return;
        useSpecialMove(1);
      });

      whiteSpecialBtn.addEventListener('click', function() {
        if (gameState.gameMode !== 'player-vs-player' || gameState.currentPlayer !== 2 || gameState.specialGauges[2] < 100 || gameState.specialCooldowns[2] > 0 || gameState.isProcessingMove) return;
        useSpecialMove(2);
      });

      resetBtn.addEventListener('click', resetGame);
      undoBtn.addEventListener('click', undoMove);
      hintBtn.addEventListener('click', toggleHints);
      skipBtn.addEventListener('click', handleSkip);
      closeModal.addEventListener('click', () => resultModal.style.display = 'none');
      newGameBtn.addEventListener('click', resetGame);
      playAgainBtn.addEventListener('click', resetGame);
      difficultyBtns.forEach(btn => btn.addEventListener('click', () => changeDifficulty(btn.dataset.level)));
      window.addEventListener('click', (e) => { if (e.target === resultModal) resultModal.style.display = 'none'; });
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && gameState.isSelectingSpecialTarget) cancelTargetSelection();
      });

      // ターゲット選択のキャンセル
      function cancelTargetSelection() {
        gameState.isSelectingSpecialTarget = false;
        gameState.isSpecialMoveActive = false;
        const targetCells = document.querySelectorAll('.seal-target, .reversal-target');
        targetCells.forEach(cell => {
          cell.classList.remove('seal-target', 'reversal-target');
          cell.removeEventListener('click', handleSealTarget);
          cell.removeEventListener('click', handleReversalTarget);
        });
        status.textContent = `${gameState.currentPlayer === 1 ? '黒' : '白'}の番です`;
        updateBoard();
      }

      // 初期化
      showGameModeModal();
      renderBoard();
    });
  </script>
</body>
</html>